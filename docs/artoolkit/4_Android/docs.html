<h1 id="artoolkit-for-android">ARToolKit for Android</h1>
<p>ARToolKit is a computer vision library that provides the tracking functionality required to build augmented reality applications. It has been ported to various hardware and software platforms, with recent focus specifically on the mobile domain.</p>
<p>This section of the ARToolKit support library describes the port of ARToolKit to the <a href="http://developer.android.com/index.html">Android</a> mobile platform. Android is an open-source software stack for mobile devices that provides the operating system, as well as middleware, key applications and APIs. In addition to the appeal of the open environment, Android has also seen an increasing consumer market share, making it an attractive platform for commercial apps and advertising.</p>
<p>For application development, Android offers a rich <a href="http://developer.android.com/sdk/index.html">SDK</a> and development tools, based around the Java programming language. While Java is sufficient for the majority of applications, the JNI framework (Java Native Interface) can be used to implement parts of a Java application in C/C++. The <a href="http://developer.android.com/sdk/ndk/overview.html">NDK</a> (Native Development Kit) provides the necessary tools, headers and libraries to take advantage of JNI on Android. There are two major motivations for using native code: to potentially increase performance, and to reuse existing C/C++ libraries. In the case of porting ARToolKit to Android, both of these motivations come into play.</p>
<p>The first section, <em>ARToolKit&#39;s SDK Structure</em> link below, covers the structure of ARToolKit and how to use it to develop your own augmented reality applications on Android. The SDK offers several different development paths, depending on the developer’s preference for Java or native coding. A certain amount of prior knowledge of Android development is essential, and assumed.</p>
<h2 id="index">Index</h2>
<ul>
<li><a href="4_Android:android_sdk">ARToolKit&#39;s SDK Structure</a></li>
<li><a href="4_Android:android_examples">Example Applications</a></li>
<li><a href="4_Android:android_developing">Developing with ARToolKitWrapper and ARBaseLib</a></li>
<li><a href="4_Android:android_native">Native Development Information</a></li>
<li><a href="4_Android:android_preferences_activity">Camera Preferences</a></li>
<li><a href="4_Android:android_camera_calibration_service">Using Automatic Online Camera Calibration Retrieval</a></li>
<li><a href="4_Android:android_camera_calibration">ARToolKit Camera Calibration for Android</a> - <a href="https://play.google.com/apps/testing/com.artoolworks.ar.utils.calib_camera">View in Google Play Store</a></li>
<li><a href="7_Examples:example_codex_interactivus">Codex Interactivus for Android</a> - <a href="https://play.google.com/store/apps/details?id=com.artoolworks.CodexInteractivus">View in Google Play Store</a></li>
<li><a href="4_Android:android_bt-200">Advanced Device-Specific Setup - Epson Moverio BT-200</a></li>
</ul>
<h1 id="epson-moverio-bt-200-setup">Epson Moverio BT-200 Setup</h1>
<p>ARToolKit offers support for the Epson Moverio BT-200 device. The BT-200 is an <a href="8_Advanced_Topics:config_optical_see-through">optical-see-through</a> stereo augmented reality headset with a single camera mounted on the right-hand side of the device that runs on <a href="4_Android:android_about">Android</a>. The stated horizontal field of view is 20 degrees.</p>
<h2 id="setting-up">Setting up</h2>
<p>The easiest means of getting pre-built apps onto the Moverio is using the <code>adb</code> tool included with the Android SDK. Some configuration may be necessary to get ADB to recognise the BT-200.</p>
<p>On OS X/Linux: Edit the file \~/.android/adb_usb.ini (ignore the &quot;DO NOT EDIT&quot; warnings in this file) and add the BT-200&#39;s USB vendor code on a line by itself, so that the file looks something like this:</p>
<p>&lt;pre&gt;
    # ANDROID 3RD PARTY USB VENDOR ID LIST -- DO NOT EDIT.
    # USE &#39;android update adb&#39; TO GENERATE.
    # 1 USB VENDOR ID PER LINE.
0x04B8
&lt;/pre&gt;
On Windows: Install the BT-200 USB driver.

To install a pre-supplied .apk file using adb, from the command line:
&lt;pre&gt;
    ./adb install myfancyapp.apk
&lt;/pre&gt;

</p>
<h2 id="calibration">Calibration</h2>
<p>Camera calibration data for the Epson BT-200 has already been generated by ARToolKit and is present in the online camera calibration database, and is usable by any ARToolKit-based application deployed to the BT-200, provided the device itself has an internet connection. Should you wish to run the Camera Calibration app yourself, ARToolKit is able to supply this as an .apk file on request.</p>
<p>Optical calibration is performed using a version of ARToolKit&#39;s calib_optical utility developed for Android devices. This is available from ARToolworks on request. Further information on optical calibration is available on the page <a href="8_Advanced_Topics:config_optical_see-through">Using an Optical See-Through Display</a>.</p>
<h1 id="camera-calibration-app-for-android">Camera Calibration App for Android</h1>
<p>For augmented reality to work properly on a device, we need to know some information about that device&#39;s camera. The <a href="https://play.google.com/store/apps/details?id=com.artoolworks.ar.utils.calib_camera">&quot;ARToolKit Camera Calibrator&quot; app</a> allows ARToolKit to better understand the camera and lens on your Android device. Producing good quality calibrations using this app can be used to improve ARToolKit tracking on your device.</p>
<p>All data captured in this app goes into the ARToolKit lens calibration data server, to help everyone who uses the same type of phone as you do augmented reality with ARToolKit.</p>
<h2 id="requirements">Requirements</h2>
<ul>
<li><em>The <a href="https://play.google.com/store/apps/details?id=com.artoolworks.ar.utils.calib_camera">&quot;ARToolKit Camera Calibrator&quot; app</a> requires Android v2.2 or later.</em></li>
<li>The PDF of the calibration file to print- either in <a href="http://artoolkit.org/docs/Calibration%20chessboard%20(A4).pdf">A4</a> or <a href="http://artoolkit.org/docs/Calibration%20chessboard%20(US%20Letter).pdf">US Letter</a> size.</li>
<li>A printer is required to print the calibration pattern.</li>
<li>A network connection (e.g. wifi or cellular data) is required to upload the data. Without this, the app does not serve any useful purpose.</li>
</ul>
<h2 id="how-it-works">How it Works</h2>
<p>The calibration pattern consists of a grid of black and white squares surrounded by a white border. Due to how camera lenses work, when straight lines are viewed through the camera lens, they will naturally bend in accordance to the hemisphere of the lens itself. The <a href="https://play.google.com/store/apps/details?id=com.artoolworks.ar.utils.calib_camera">&quot;ARToolKit Camera Calibrator&quot; app</a> locates the corners of the squares and then measures the spacing between the corners and uses this information to calculate the lens distortion. The more images captured, and the more angles they are captured from, the lower the error in the distortion measurement. For this reason, in this app we capture 10 images.</p>
<h3 id="get-and-print-the-pattern">Get and Print the Pattern</h3>
<ol>
<li>Download the calibration chessboard in <a href="http://artoolkit.org/docs/Calibration%20chessboard%20(A4).pdf">A4</a> or <a href="http://artoolkit.org/docs/Calibration%20chessboard%20(US%20Letter).pdf">US Letter</a> size.<ul>
<li>(OPTIONAL) The calibration chessboards can also be found under the <code>doc/patterns</code> folder of the ARToolKit SDK as <code>Calibration chessboard (A4).pdf</code>, or <code>Calibration chessboard (US Letter).pdf</code>, respectively.</li>
<li>(OPTIONAL) The calibration chessboards can also be printed from the app (via Google Cloud Print service) by selecting the &quot;Print&quot; button from app. To access the Print button, press the hardware menu button on the device or use the menu button on the Action Bar at the top of the screen (it looks like three vertical dots).</li>
</ul>
</li>
<li>Print the calibration chessboard you downloaded <em>at 100% sizing</em>, and be sure that no clipping of the pattern occurs.
<img src="../_media/print_dialog.png" alt="An example of the print dialog on Mac OS X, showing the PDF being printed at 100% of its size."></li>
</ol>
<p>When preparing your environment for calibrating your camera, there are a couple of best practices to keep in mind:</p>
<ul>
<li>Since the chessboard pattern is assumed to be flat, <em>make sure that the chessboard pattern lays completely flat</em>.<ul>
<li>We recommend you firmly affix the chessboard to a flat surface (such as a table or piece of acrylic) using spray adhesive or double-sided tape. Very thick card stock also works well.</li>
</ul>
</li>
<li>Make sure that the chessboard pattern is in a well-lit area, and is not obscured or occluded in any way.</li>
</ul>
<h3 id="get-and-launch-the-app">Get and Launch the App</h3>
<p><a href="https://play.google.com/store/apps/details?id=com.artoolworks.ar.utils.calib_camera"><img src="../_media/play_store.png" alt="The &quot;ARToolKit Camera Calibrator&quot; app in the Google Play Store."></a>
<a href="https://play.google.com/store/apps/details?id=com.artoolworks.ar.utils.calib_camera">The &quot;ARToolKit Camera Calibrator&quot; app can be installed from the Google Play Store.</a> Once you have downloaded the app, either choose &quot;Open&quot; from the Play Store page, or locate the application in your app drawer and launch it from there.</p>
<h3 id="choosing-settings">Choosing Settings</h3>
<p>The device you are using may have multiple cameras (such as front and back), as well as multiple resolution modes (sizes of images each camera can capture). <em>You do not need to calibrate every resolution of every camera,</em> though it would be great if you did so. When you launch the app, there should be three vertical dots in the upper right-hand corner, tap this, and then tap &quot;Settings&quot; from the menu that appears.
<img src="../_media/menu.png" alt="The &quot;ARToolKit Camera Calibrator&quot; menu.">
First and foremost, we recommend checking the &quot;Force landscape display&quot; checkbox, as you will be moving the phone around at many angles, and swapping layout is not recommended.</p>
<h4 id="choosing-which-resolution-s-to-calibrate">Choosing Which Resolution(s) to Calibrate</h4>
<p>Choosing which resolution(s) to calibrate against can be somewhat difficult. Practically every camera maker uses a different camera module, which in turn has different video modes. <em>There is no resolution guaranteed to be available on all Android devices. That being said, 320x240 (4:3) is available on most devices.</em>
<img src="../_media/resolutions.png" alt="The resolution selections available on a Google Nexus 5.">
The good news is that it&#39;s not the resolution that matters as much as the aspect ratio. Therefore, we recommend you capture one resolution of each aspect ratio for the camera on your device. The most common standard aspect ratios are 4:3, 3:2, and 16:9. We recommend you calibrate for each of these three aspect ratios, if available.</p>
<h4 id="why-calibrate-the-front-camera-">Why Calibrate the Front Camera?</h4>
<p>Because some AR applications actually make use of the front camera! If your application uses the front camera, or you want to do a good service, we recommend you follow the above resolution recommendations for the front camera also.</p>
<h4 id="selecting-your-chessboard">Selecting your Chessboard</h4>
<p><img src="../_media/paper.png" alt="Choosing which chessboard you&#39;ve printed via the menu.">
If you&#39;ve downloaded and printed the A4-sized pattern, select &quot;A4&quot;. If you&#39;ve downloaded and printed the US Letter-sized pattern, select &quot;US Letter&quot;.</p>
<h3 id="capturing-calibration-images">Capturing Calibration Images</h3>
<p>Press the back button (left triangle) to return to the camera feed, and tap the screen in the center box to begin.
<img src="../_media/beginning.png" alt="The app upon first launch, instructing you to touch the box to proceed to calibrating.">
You will be capturing a total of 10 images during this calibration. In the bottom-center of the capture window is displayed the number of images captured so far. <em>Touching the screen captures an image, so be careful as you reposition yourself. You can always repeat these 10 image captures again if it did not go well the first time.</em></p>
<p><a href="../_media/good_bad.png">On the left: A good camera capture. On the right: A bad camera capture.</a>
Point the camera at the chessboard grid, and the inner corners of the squares will be highlighted with &quot;X&quot; marks and numbered. Be sure to keep the entire chessboard in view, and hold still during capture.</p>
<p>When the camera can clearly see all the intermediate corners, the X marks turn RED, and a calibration image can be captured- This is good! On the other hand, if some of the corners are obscured by the edges of the camera frame, or poor lighting or reflection, the crosses will be GREEN, and no calibration image can be captured until the optical conditions are changed. This is bad!</p>
<p>In order to obtain a good calibration for the camera, it is important to obtain images of the calibration board at a variety of angles to the camera lens. The images below give examples of the configurations of the calibration board you should try to obtain.
<a href="../_media/framed1.png">An example of good framing.</a> <a href="../_media/framed2.png">Another example of good framing.</a>
Capturing these images involves holding the camera at different angles to the board, including upside-down. We do not recommend exceeding an angle of 45 degrees during capture. Do this a total of 10 times.</p>
<h3 id="finishing-up">Finishing Up</h3>
<p>Once you&#39;ve captured all 10 images, the screen will display &quot;Calculating camera parameters...&quot;. Once it has finished it will display your results, like so:
<a href="../_media/results.png">The results for a calibration captured on a Google Nexus 5.</a>
This screen displays the minimum, maximum, and average error from the frames captured. <em>In general, having an error threshold below 1.0 is good. If your standard error is above 5 on a non-HD resolution, we recommend you complete the calibration again, being careful with camera focus, chessboard flex, and lighting.</em></p>
<p>Congratulations! You&#39;ve calibrated your camera! We recommend you go and calibrate for the rest of the recommended aspect ratios, listed above.</p>
<h2 id="what-information-is-collected-">What Information is Collected?</h2>
<p>If a calibration dataset generated with the app meets a certain minimum level of quality is saved at the completion of calibration, and uploaded when a network connection is available. The calibration file itself contains lens optical and distortion parameters (a structure known as ARParam, if you are familiar with the ARToolKit source).</p>
<p>As well as the calibration file itself, the following information is transmitted:</p>
<ul>
<li>The make and model of device (e.g. Samsung Galaxy S).</li>
<li>Which camera on the device the parameters apply to.</li>
<li>The date and time at which the calibration file was generated.</li>
<li>The calibration data quality (error values).</li>
</ul>
<p>No personally identifying data is transmitted or stored during as part of the process. Additionally, the data is uploaded via a secure HTTPS connection.</p>
<h1 id="camera-calibration-service">Camera Calibration Service</h1>
<p>Every device uses a different camera, and each of these cameras have variables which affect the ability of ARToolKit (and all computer vision) to work properly. The camera calibration service is a cloud-and-crowd-based solution to generating and retrieving these camera-specific variables.</p>
<h2 id="what-information-is-collected-">What Information is Collected?</h2>
<p>This service does not store or transmit any personally identifying information.</p>
<p>If a network connection is available, the following information may be transmitted to an ARToolworks server for the purpose of retrieving camera calibration information for your specific Android device:</p>
<ul>
<li>The make and model of device (e.g. Samsung Galaxy S).</li>
<li>Which camera on the device is being used.</li>
</ul>
<p>No personally identifying data is transmitted or stored during any part of the process. Additionally, the data is transferred via a secure HTTPS connection.</p>
<h2 id="requirements">Requirements</h2>
<p>The camera calibration service has a few requirements to use. Namely, internet.</p>
<h3 id="library-linkage">Library Linkage</h3>
<h4 id="artoolkit-for-android-v5-3-1-and-later-">ARToolKit for Android v5.3.1 and later.</h4>
<p>All apps running the camera calibration service depend on native library libcurl. As of ARToolKit v5.3.1, libcurl and its dependencies libssl and libcrypto are supplied as a statically linked library. Applications that link to ARBaseLib or libARWrapper will automatically load these dependencies.</p>
<h4 id="artoolkit-for-android-v4-x-v5-3">ARToolKit for Android v4.x - v5.3</h4>
<p>All apps running the camera calibration service depend on native library libcurl. In ARToolKit v4.x - v5.3.0, libcurl and its dependencies libcrypto and libssl are supplied as dynamic libraries. Applications that link to ARBaseLib will automatically load these dependencies, but other examples not based on ARBaseLib must add these loadLibrary calls, ideally in a subclass of Android.Application or Android.Activity:</p>
<p>&lt;pre&gt;
    System.loadLibrary(&quot;crypto&quot;);
    System.loadLibrary(&quot;ssl&quot;);
    System.loadLibrary(&quot;curl&quot;);
&lt;/pre&gt;

</p>
<h3 id="manifest">Manifest</h3>
<p>&lt;pre&gt;
    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;
    &lt;uses-feature android:name=&quot;android.hardware.camera.any&quot; /&gt;
    &lt;uses-feature android:name=&quot;android.hardware.camera&quot; android:required=&quot;false&quot; /&gt;
    &lt;uses-feature android:name=&quot;android.hardware.camera.autofocus&quot; android:required=&quot;false&quot; /&gt;
    &lt;uses-feature android:glEsVersion=&quot;0x00010100&quot; /&gt;
&lt;/pre&gt;

</p>
<h2 id="how-do-i-contribute-to-the-service-">How do I Contribute to the Service?</h2>
<p>Currently, the service is used exclusively on the Android platform through the <a href="4_Android:android_camera_calibration">Camera Calibration App for Android</a>.</p>
<h1 id="developing-with-artoolkitwrapper-and-arbaselib">Developing with ARToolKitWrapper and ARBaseLib</h1>
<p>Using the included ARToolKitWrapper native library and ARBaseLib Android library, it is simple to get an ARToolKit application up and running. Developers should refer to the ARSimple example included in the SDK as it is the most basic example and follows the development strategy described in this section.</p>
<h2 id="arwrapper">ARWrapper</h2>
<p>ARWrapper is a native C++ shared library that exposes a small set of functions for managing the lifecycle of an ARToolKit application, including initialization, adding markers, getting the projection matrix, querying transformations, and cleaning up at the end. Using JNI, these functions are mapped to a class within the ARBaseLib Android library so that they can be called from Java. The diagram below illustrates this.</p>
<p><img src="../_media/artoolkitwrapper_arbaselib.png" alt="artoolkitwrapper_arbaselib"></p>
<p>The API documentation for ARWrapper can be found at <code>doc/apiref-ARWrapper/html/index.html</code> in the SDK.</p>
<p>To start a new Android application project in AndroidStudio, you will need to copy the built ARWrapper shared library into the project directory. Note that this step is performed automatically for the supplied ARToolKit Android example projects.</p>
<p><img src="../_media/libs_directory.png" alt="250px"></p>
<p>You can copy the entire libs directory from: <code>android/libs</code>
Plase ensure that you run the build.sh and build_native.sh prior to copying the directory. Read the <a href="4_Android:android_native">Android Native Development</a> for more information.</p>
<p>Note: There are subdirectories for each CPU architecture, including armeabi, armeabi-v7a, mips and x86. It is the same library built for different instruction sets. The appropriate version is automatically chosen at runtime.</p>
<h2 id="arbaselib">ARBaseLib</h2>
<p>ARBaseLib provides additional classes to simplify development. ARBaseLib is an Android library, meaning that it isn&#39;t an Android application itself, but can make use of the Android framework. Android applications can reference the library, and AndroidStudio will take care of including the necessary files when the APK is built and deployed. This allows reusable components to be placed in the library and used in many different examples and applications. To use ARBaseLib, import the ARBaseLib as new module to your AndroidStudio project:</p>
<ol>
<li><strong>File/Project Structure...</strong></li>
<li>Add a new module with the <strong>+</strong> button at the top left of by pressing ⌘+N (OSX) Alt+Insert (Windows)</li>
<li>Select <strong>Import .JAR/.AAR Package</strong> hit Next</li>
<li>Select the file with the <code>...</code> on the right of the first text field. The ARBaseLib.aar file is located in $ARTOOLKIT5_ROOT/AndroidStuiodProjects/ARBaseLibProj/arBaseLib/build/outputs/aar/<ul>
<li>If it is not there open the project ARBaseLibProject separately with AndroidStudio and build it.</li>
</ul>
</li>
<li>Change the <strong>Subproject name</strong> to <strong>aRBaseLib</strong></li>
</ol>
<p>API documentation for the classes in ARBaseLib can be found in the <code>AndroidStudioProjects/ARBaseLibProj/doc</code> directory.</p>
<h2 id="development">Development</h2>
<p>Referencing ARBaseLib gives the application access to several new classes. Some of the key ones are:</p>
<ul>
<li>ARToolKit: A singleton class that handles the native calls.</li>
<li>ARActivity: A base class for an AR based activity.</li>
<li>ARRenderer: A base class for rendering AR scenes.</li>
</ul>
<p>ARActivity takes care of setting up the view hierarchy that will display the live augmented reality view. The AR view is created by layering an OpenGL surface over the live camera preview surface. By using a transparent background clear color in OpenGL, the live video shows through from below.</p>
<p>A FrameLayout is used to hold the views because children of a FrameLayout are stacked on top of each other – precisely the arrangement required. The following diagram illustrates how the user interface is composed to produce an AR view.</p>
<p><img src="../_media/view_layers.png" alt="view_layers"></p>
<p>ARActivity must be subclassed to be used. Abstract methods need to be overridden in the subclass to provide ARActivity with the objects it needs to work with. The first object is a FrameLayout, mentioned above, which will contain the camera and OpenGL views.</p>
<p>&lt;pre&gt;
    protected abstract FrameLayout supplyFrameLayout();
&lt;/pre&gt;

</p>
<p>To include a FrameLayout in the activity’s view hierarchy, edit the layout XML file for the activity. For example, the following layout includes a FrameLayout called mainLayout, set to be 640x480 pixels. mainLayout can be retrieved like any other view, via findViewById(), and returned from supplyFrameLayout(). Note that the actual view hierarchy may be much more complicated than the one presented here – you are free to place the AR FrameLayout within a more interesting GUI.</p>
<p>main.xml from ARSimple:</p>
<p>&lt;pre&gt;
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        android:id=&quot;@+id/topLayout&quot;
        android:orientation=&quot;horizontal&quot;
        android:layout_width=&quot;fill_parent&quot;
        android:layout_height=&quot;fill_parent&quot;&gt;

        &lt;FrameLayout
            android:id=&quot;@+id/mainLayout&quot;
            android:orientation=&quot;vertical&quot;
            android:layout_width=&quot;640px&quot;
            android:layout_height=&quot;480px&quot;/&gt;

    &lt;/LinearLayout&gt;
&lt;/pre&gt;

</p>
<p>The second required object is a renderer for displaying the AR scene. The renderer must inherit from ARRenderer, another class in ARBaseLib.</p>
<p>&lt;pre&gt;
    protected abstract ARRenderer supplyRenderer();
&lt;/pre&gt;

</p>
<p>The source code from the ARSimple example activity is shown below. It implements both the necessary functions.</p>
<p>&lt;pre&gt;
    package org.artoolkit.ar.samples.ARSimple;

    import org.artoolkit.ar.base.ARActivity; import
    com.artoolworks.ar.base.rendering.ARRenderer; import android.os.Bundle;
    import android.widget.FrameLayout;

    /<strong>
    <em> A simple example of extending ARActivity to create a new AR application.
    </em>/

    public class ARSimple extends ARActivity {
        @Override
        public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);<br>            setContentView(R.layout.main);<br>        }

        /</strong>
         <em> Provide our own SimpleRenderer.
         </em>/

        @Override
        protected ARRenderer supplyRenderer() {
            return new SimpleRenderer();
        }

        /*<em>
         </em> Use the FrameLayout in this Activity&#39;s UI.
         */

        @Override
        protected FrameLayout supplyFrameLayout() {
            return (FrameLayout)this.findViewById(R.id.mainLayout);<br>        }
    }
&lt;/pre&gt;

</p>
<p>ARRenderer is a baseclass for renderers of AR scenes. It is essentially a standard Android GLSurfaceView.Renderer, but adds some custom code and some methods which should be overridden by the subclass.</p>
<p>&lt;pre&gt;
    protected abstract void configureARScene();
&lt;/pre&gt;

</p>
<p>This method is called on the renderer once initialization is complete. At this point, markers can be added, for example.</p>
<p>&lt;pre&gt;
    public void draw(GL10 gl);
&lt;/pre&gt;

</p>
<p>This method is called when the rendering should be updated. ARActivity automatically only refreshes the renderer when the ARToolKit tracking has been updated. ARRenderer also performs checks to see that marker detection is up and running before calling draw. This ensures the ARToolKit projection matrix and markers are ready to be used during the rendering pass.</p>
<p>The source code from the SimpleRenderer used in the ARSimple example is shown below. When the configuration method is called, it adds a marker, recording its ID for later use. When the draw method is called, the ARToolKit object is used to retrieve the projection matrix, and query and retrieve tracking information for the loaded marker. OpenGL functions are then used to apply the matrices and display a cube on the marker (using a Cube utility class from ARBaseLib).</p>
<p>&lt;pre&gt;
    package org.artoolkit.ar.samples.ARSimple;

    import javax.microedition.khronos.opengles.GL10; import
    org.artoolkit.ar.base.ARToolKit; import
    org.artoolkit.ar.base.rendering.ARRenderer; import
    org.artoolkit.ar.base.rendering.Cube;

    /<strong>
    <em> A very simple Renderer that adds a marker and draws a cube on it.
    </em>/

    public class SimpleRenderer extends ARRenderer {
        private int markerID = -1;
        private Cube cube = new Cube(80.0f, 0.0f, 0.0f, 40.0f);

        /</strong>
         <em> Markers can be configured here.
         </em>/

        @Override
        public boolean configureARScene() {

            markerID = ARToolKit.getInstance().addMarker(&quot;single;/sdcard/AR/Data/patt.hiro;80&quot;);
            if (markerID &lt; 0) return false;`

            return true;
        }

        /*<em>
         </em> Override the draw function from ARRenderer.
         */

        @Override
        public void draw(GL10 gl) {
            gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);

            // Apply the ARToolKit projection matrix
            gl.glMatrixMode(GL10.GL_PROJECTION);
            gl.glLoadMatrixf(ARToolKit.getInstance().getProjectionMatrix(), 0);

            // If the marker is visible, apply its transformation, and draw a cube
            if (ARToolKit.getInstance().queryMarkerVisible(markerID)) {
                gl.glMatrixMode(GL10.GL_MODELVIEW);
                gl.glLoadMatrixf(ARToolKit.getInstance().queryMarkerTransformation(markerID), 0);
                cube.draw(gl);
            }
        }
    }
&lt;/pre&gt;

</p>
<p>Clearly much more complicated rendering can be achieved through more advanced OpenGL calls, or the use of a third-party rendering engine. The OpenGL rendering can occur in either Java or native C/C++, or even a combination of the two.</p>
<p>The ARSimpleNative example (and its accompanying native library ARWrapperNativeExample) demonstrates how to call into native code to perform essentially the same OpenGL rendering that ARSimple does in Java.</p>
<h2 id="additional-notes">Additional Notes</h2>
<h3 id="data-files">Data Files</h3>
<p>Data files used by ARToolKit include <a href="4_Android:android_camera_calibration">camera parameters</a>, files with lists of markers, marker <a href="3_Marker_Training:marker_training">pattern files</a>, <a href="3_Marker_Training:marker_nft_training">NFT datasets</a>, and 3D model files. You get these files into your app&#39;s filesystem by placing them in folders inside your project’s &quot;assets&quot; folder. When your app runs, you make a call to ARBaseLib&#39;s AssetHelper class to unpack them (preferably just once, from an Application subclass). AssetHelper moves the assets from your application&#39;s .apk file into the application&#39;s cache on the internal storage. On subsequent launches, the assets are used from cache, saving time. Also, if space on the device is short, Android can clear this cache automatically, or the user manually. Finally, if the app is uninstalled, this space is reclaimed.</p>
<p><em>One rule needs to be observed: if the application&#39;s assets are changed, the &quot;VersionCode&quot; field (an integer) in the application&#39;s AndroidManifest.xml MUST be changed (usually incremented).</em></p>
<p>The <a href="4_Android:android_examples">ARToolKit for Android examples</a> provide working example code. The following code (from ARSimple&#39;s ARSimpleApplication.java class) demonstrates the unpacking of one folder, &quot;Data&quot; into the cache on the filesystem.</p>
<p>&lt;pre&gt;
    // Here we do one-off initialization which should apply to all activities
    // in the application.
    protected void initializeInstance() {

        // Unpack assets to cache directory so native library can read them.
        // N.B.: If contents of assets folder changes, be sure to increment the
        // versionCode integer in the AndroidManifest.xml file.
        AssetHelper assetHelper = new AssetHelper(getAssets());<br>        assetHelper.cacheAssetFolder(getInstance(), &quot;Data&quot;);
    }
&lt;/pre&gt;

</p>
<h3 id="loading-markers">Loading Markers</h3>
<p>The method to add a marker takes a marker configuration string, which is simply a semicolon-separated list of fields that describe the marker to load. The syntax is:</p>
<ul>
<li>For single markers: <code>single;path_to_pattern_file;pattern_width</code></li>
</ul>
<p>Example: <code>single;/sdcard/AR/Data/patt.hiro;80</code></p>
<ul>
<li>For multi markers: <code>multi;path_to_multi_config_file</code></li>
</ul>
<p>Example: <code>multi;/sdcard/AR/Data/multi/marker.dat</code></p>
<p>&lt;pre&gt;
    int markerID = ARToolKit.getInstance().addMarker(&quot;single;/sdcard/AR/Data/patt.hiro;80&quot;);
&lt;/pre&gt;

</p>
<h3 id="application-permissions">Application Permissions</h3>
<p>In order to access the camera the application requires permissions which are set in the AndroidManifest.xml file. Ensure these are set correctly.</p>
<p>&lt;pre&gt;
    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;
    &lt;uses-feature android:name=&quot;android.hardware.camera&quot; /&gt;
    &lt;uses-feature android:name=&quot;android.hardware.camera.autofocus&quot; /&gt;
&lt;/pre&gt;

</p>
<h3 id="application-configuration">Application Configuration</h3>
<p>There is an issue where ARActivity initializes more than once when the orientation changes to landscape. To fix this, set the configChanges field for the application in the AndroidManifest.xml file as shown:</p>
<p>&lt;pre&gt;
&lt;application
android:icon=&quot;@drawable/icon&quot;
android:label=&quot;@string/app_name&quot;
android:configChanges=&quot;keyboardHidden|orientation&quot; &gt;
&lt;/pre&gt;

</p>
<h2 id="developing-directly-with-artoolkit">Developing directly with ARToolKit</h2>
<p>For developers who want more control and direct access to ARToolKit functions, the core ARToolKit modules are available as static libraries:</p>
<ul>
<li>libar: core AR functions</li>
<li>libaricp: Iterative Closest Point functions (provided as
ebuilt binary only)</li>
<li>libarmulti: multimarker support</li>
<li>libeden: additional math and rendering functions</li>
<li>libgl: OpenGL functions, particularly for video texturing</li>
</ul>
<p>These static libs (.a files) are provided prebuilt in <code>ARToolKit\android\jni\prebuilt</code>, or if the ARToolKit library is rebuilt, the latest versions will be created in <code>ARToolKit\android\obj\local</code>.</p>
<p>By referencing these static libraries, a native Android shared library can be created that directly calls ARToolKit using its standard C API. Then, by exposing JNI compatible functions from within that library, the developer can access their native code from the Java code in their Android application. This approach is exactly how the C++ wrapper included in the SDK operates.</p>
<p>Note that the entire ARToolKit API is not exposed to Java. Instead, implement ARToolKit functions in C/C++ and call these functions as needed from Java. The following diagram illustrates this approach.</p>
<p><img src="../_media/artoolkit_direct.png" alt="artoolkit_direct"></p>
<h3 id="arnative-example">ARNative Example</h3>
<p>The ARNative example (and its accompanying native library libARNative) demonstrate how to create a shared library, expose functions via JNI, and call them from an Android activity. It does not use either ARToolKitWrapper or ARBaseLib, so is the closest example to a “standard” ARToolKit application in the SDK.</p>
<p>Rather than combining Android camera and OpenGL views to synthesize an AR view, ARNative uses texture mapping to display the video background, using standard ARToolKit functions. However, the camera preview surface must still be placed in the activity’s view hierarchy to permit video capture. The preview can be hidden from view under the OpenGL surface however.</p>
<h1 id="android-examples">Android Examples</h1>
<p>ARToolKit includes a number of fully-working examples on Android that demonstrate basic and advanced techniques. You can copy and build on the examples to create your own application. Each app is built against a selected API level of the Android SDK Platform and does not have dependencies on Google APIs. The ARToolKit SDK example apps are in the process of being upgraded to be built over the latest and greatest Android SDK Platform API level. However, the example apps will likely lag behind as newer Android SDK Platforms are released. Coming soon - the example apps projects are being migrated to the Android Studio integrated development environment (IDE) from the Eclipse projects.</p>
<p>The examples are divided into 3 sets.</p>
<ol>
<li>All Java-based: examples where all user-developed code is in Java, and is based on the provided ARBaseLib classes.</li>
<li>Mixed Java and native C/C++ using Android NDK: examples where user-developed code is split between the Java environment and native C/C++ environment. Code can use the provided ARBaseLib java classes while also addressing ARToolKit in C/C++ via the libARWrapper C/C++ API.</li>
<li>AR and rendering code in native C/C++ using Android NDK: examples where most of the user-developed code is native C/C++. These examples offer the greatest power to the AR developer and direct access to the full native ARToolKit API.</li>
</ol>
<p>The examples are as follows:</p>
<h2 id="all-java-based">All Java-based</h2>
<ul>
<li><strong>ARSimple</strong>: An example that extends the ARActivity class in ARBaseLib to create a simple augmented reality application.</li>
<li><strong>ARSimpleInteraction</strong>: An example that adds simple interaction to ARSimple.</li>
<li><strong>ARMulti</strong>: An example that shows how to configure and usenmulti marker tracking.</li>
<li><strong>ARDistanceOpenGLES20</strong>: An example on how to measure the distance and draw a line between two markers. The line is drawn using OpenGL ES 2.0 library features.</li>
<li><strong>ARMarkerDistance</strong>: An example on how to measure the distance and draw a line between two markers. The lin is drawn using OpenGL ES 1.0 library features.</li>
<li><strong>ARSimpleOpenGLES20</strong>: Pretty much the same as ARSimple with the extension of using OpenGL ES 2.0 features for drawing and coloring the cube.</li>
</ul>
<h2 id="mixed-java-and-native-c-c-using-android-ndk">Mixed Java and Native C/C++ Using Android NDK</h2>
<ul>
<li><strong>ARSimpleNative</strong>: An example that uses an additional native library to perform rendering in C rather than Java.</li>
<li><strong>ARSimpleNativeCars</strong>: An example that uses a native OBJ model loader.</li>
</ul>
<h2 id="ar-and-rendering-code-in-native-c-c-using-android-ndk">AR and Rendering Code in Native C/C++ Using Android NDK</h2>
<ul>
<li><strong>ARNative</strong>: An example that uses the ARToolKit libraries directly and renders with OpenGL ES 2.0.</li>
<li><strong>ARNativeES1</strong>: An example that uses the ARToolKit libraries directly and renders with OpenGL ES 1.0.</li>
<li><strong>ARNativeOSG</strong>: An example that uses the ARToolKit libraries directly and loads and renders 3D model content using the advanced OpenSceneGraph framework.</li>
<li><strong>nftSimple</strong>: An example that performs NFT (texture tracking) and renders with OpenGL.</li>
<li><strong>nftBook</strong>: An example that performs NFT (texture tracking) and loads and renders 3D model content using the advanced OpenSceneGraph framework.</li>
<li><strong>ARMovie</strong>: An example that performs NFT (texture tracking) and loads and renders 2D video content on devices running Android 4.0.3 and later.</li>
</ul>
<h4 id="arnative">ARNative</h4>
<p>Loads marker names from a configuration file. (Square markers only.) The tracking will automatically be set to match the types of square markers (template (pictorial) vs. matrix (barcode)) used in the configuration file. It is not recommended that template and matrix markers are mixed in the same application, as this lowers the tracking reliability of both types.</p>
<h4 id="arnativeosg">ARNativeOSG</h4>
<p>Loads marker names from a configuration file. (Square markers only.) The tracking will automatically be set to match the types of square markers (template (pictorial) vs. matrix (barcode)) used in the configuration file. It is not recommended that template and matrix markers are mixed in the same application, as this lowers the tracking reliability of both types.</p>
<p>Management of OSG objects is encapsulated in a C-pseudoclass named VirtualEnvironment, which in turn acts through the API offered by the ARosg library. ARosg contains a reasonable amount of functionality for manipulating the scene graph. See the <a href="http://www.artoolworks.com/support/doc/artoolkit5/apiref/arosg_h/index.html">API documentation for libARosg</a>.</p>
<h4 id="nftsimple">nftSimple</h4>
<p>Loads NFT dataset names from a configuration file.</p>
<p>The example uses the &quot;Pinball.jpg&quot; image supplied in the &quot;Misc/patterns&quot; folder. ARToolKit NFT requires a fast device, preferably dual-core for good operation, e.g. Samsung Galaxy SII or similar. Build/deployment for Android API 9 (Android OS v2.3) or later is recommended.</p>
<h4 id="nftbook">nftBook</h4>
<p>Loads NFT dataset names from a configuration file.</p>
<p>The example uses the &quot;Pinball.jpg&quot; image supplied in the &quot;Misc/patterns&quot; folder. ARToolKit NFT requires a fast device, preferably dual-core for good operation, e.g. Samsung Galaxy SII or similar. Build/deployment for Android API 9 (Android OS v2.3) or later is recommended.</p>
<p>Management of OSG objects is encapsulated in a C-pseudoclass named VirtualEnvironment, which in turn acts through the API offered by the ARosg library. ARosg contains a reasonable amount of functionality for manipulating the scene graph. See the <a href="http://www.artoolworks.com/support/doc/artoolkit5/apiref/arosg_h/index.html">API documentation for libARosg</a>.</p>
<h4 id="armovie">ARMovie</h4>
<p>Shows an example of playback of a video file on a marker surface. The example is NDK (native)-based. Movie playback is only supported by Android OS v4.0 (&quot;Ice Cream Sandwich&quot;) and later (Android API level 14), and support varies in quality and reliability from device to device. It is highly recommended that you provide alternate playback mechanisms for devices where playback in the AR environment cannot proceed, e.g. full screen playback.</p>
<h1 id="android-native-development">Android Native Development</h1>
<p>The ARToolKit SDK package and the git cloned GitHub local repository of &quot;artoolkit5&quot; includes prebuilt native libraries. It&#39;s advised that a local repository be used since the downloaded SDK package is rarely up-to-date with the repository. If you are not planning on altering any native code then you do not need to consult this section or install the Android NDK. On the other hand, if you want to implement part of your AR application in native code, then you will need to build ARToolKit native C/C++ dependencies.</p>
<h2 id="prerequisites">Prerequisites</h2>
<p>Building native ARToolKit libraries requires a development environment capable of building native libraries for Android using the Android NDK (NDK 11+). Currently, ARToolKit actively supports the Android development systems of Mac OS X 9+ and Windows Desktop 8.1 and 10. However, there are those in the ARToolKit community who have successfully developed using Linux.</p>
<blockquote>
<p>Note: This is by no means a comprehensive guide on how to setup an NDK development environment. If you need assistance in this area, please search online as there are many tutorials and articles covering this topic and it is outside the scope of this user guide.</p>
</blockquote>
<p>The following SDKs and tools should be installed and configured correctly on one of the chosen supported development systems.</p>
<h5 id="these-are-required-tools-for-standard-android-sdk-development-">These are required tools for standard Android SDK development:</h5>
<ul>
<li><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Standard Edition Java Development Kit</a> 1.7 or greater</li>
<li><a href="http://developer.android.com/sdk/index.html">Android Studio IDE</a> - version 1.5.x or greater</li>
<li><p><a href="http://developer.android.com/sdk/index.html">Android SDK</a> (Downloaded with Android Studio IDE)     </p>
<ul>
<li>On Mac OS X: Default install path: <strong>/Users/[username]/Library/Android/sdk</strong></li>
<li>On Windows Desktop: Recommended install path: <strong>C:\Users[username]\Android\sdk</strong></li>
</ul>
</li>
<li><p>Android NDK: Download and installation details described below</p>
</li>
</ul>
<h5 id="requirements-for-building-native-code-with-the-ndk-within-or-outside-of-the-android-studio-ide-">Requirements for building native code with the NDK within or outside of the Android Studio IDE:</h5>
<ul>
<li><a href="http://tools.android.com/tech-docs/android-ndk-preview">Android NDK Preview</a> - The NDK that works with the Android Studio IDE.  Use the Android Studio IDE to download and setup the NDK preview requirements.</li>
<li><a href="https://git-scm.com">Git distributed version control system and Git bash</a> - Git DVCS is a requirement for Windows Desktop and Mac OS X. Git bash is a requirement for Windows Desktop and is not applicable to Mac OS X.</li>
</ul>
<h6 id="deprecated-development-tools-and-methods-">Deprecated development tools and methods:</h6>
<ul>
<li>Eclipse IDE</li>
<li>ADT Plugin for Eclipse</li>
<li>Android NDK plugin for Eclipse</li>
<li>Cygwin</li>
</ul>
<hr>
<h4 id="regarding-the-windows-desktop-development-environment">Regarding the Windows Desktop development environment</h4>
<p>A few Unix commands are required for the Android NDK build script, <code>ndk-build.cmd</code>, to work. These commands are provided by the Git bash shell that comes with the Git download. Because of that, we can thankfully replace Cygwin, the Unix-like environment for Windows, with Git bash. Cygwin is seemingly impractical for the meager requirements of <code>ndk-build.cmd</code> in that the Cygwin installation is large, invasive and the installation setup is confusing.</p>
<h5 id="special-git-installation-instructions-for-windows-desktop-only">Special Git installation instructions for Windows Desktop only</h5>
<p>When installing Git, from the Git setup wizard:</p>
<ul>
<li>Accept the default selected components</li>
<li>For the &quot;Adjusting your PATH environment&quot; step, select the default &quot;Use Git only&quot;</li>
<li>For the &quot;Configuring the line ending conversions&quot; step, select the default &quot;Checkout Windows-style, commit Unix-style line ends&quot;</li>
</ul>
<hr>
<p>Please try to ensure you have a working Android SDK and NDK environment before continuing. This, unfortunately, is not as easy as it sounds due the constantly evolving Android Studio tool set. Try the Hello-JNI tutorial available from <a href="https://codelabs.developers.google.com/codelabs/android-studio-jni/index.html?index=..%2F..%2Findex#0">codelabs.developers.google.com</a>. Try implementing Hello-JNI app using NDK version 11+ for reasons explained below. Strive to use the latest and greatest developers.android.com supported Gradle plugin (com.android.tools.build:gradle-experimental:x.x.x) and Gradle version (http://services.gradle.org/distributions/gradle-x.x-all.zip) combination. Depending on the supported combination of experimental Gradle plugin and Gradle version used, there are differing required source updates to the HelloAndroidJni modules&#39; build.gradle file.</p>
<p>In the tutorial, the step #5 of the &quot;Add JNI Code Into Project&quot; chapter, the C/C++ jni function prototype and the &quot;jni&quot; directory may not be created by the IDE as the IDE is supposed to do. If the IDE fails to create both, it&#39;s important to manually create the directory, <code>jni</code>, here: <code>[module root]/src/main/</code>. Once the jni directory is created you may try again to let the IDE create the <code>hellp-android-jni.c</code> file. If that fails, create and place the prototype C source file, <code>hello-android-jni.c</code>, in the <code>jni</code> directory. Add the required C source code as presented by step #5 of the tutorial.</p>
<p>Finally, once you create the new Hello-JNI Android Studio project and module, reduce the complexity of the module by deleting the &quot;Test&quot; directory from within the the IDE found under <code>[module root: &quot;app&quot;]/src/</code> in the Project pane.</p>
<p>Keep in mind that the tutorial is written for Android Studio executed on Linux or Mac OS X but Android Studio executed on Windows 10 will work as well.</p>
<blockquote>
<p>Minor Android Studio for Windows Difference: Step #7 of the &quot;Create Java Sample App&quot; chapter, in Android Studio: open &quot;File&quot; menu item, click to select &quot;Settings...&quot;, open &quot;Build, Execution, Deployment&quot; twirl, open &quot;Build Tools&quot; twirl, open &quot;Gradle&quot; twirl, under &quot;Project-level settings&quot; group-box, ensure that &quot;Use default gradle wrapper (recommended)&quot; is selected.</p>
</blockquote>
<p>For help with the Eclipse to Android Studio IDE transition, see the document [[https://github.com/artoolkit/artoolkit5/blob/master/AndroidStudioProjects/Docs/AS_Migration.pdf]].</p>
<h2 id="building-native-android-libraries">Building Native Android Libraries</h2>
<p>To build using the Android NDK toolchain, placed in the downloaded NDK is a script file, for Mac OS X, named <code>ndk-build</code> or, for Windows Desktop, named <code>ndk-build.cmd.</code> When Android Studio is used to download and install the NDK, by default, the NDK is installed directly under the Android SDK root folder. Also, by default, the NDK root folder is named &quot;ndk-bundle.&quot;</p>
<blockquote>
<p>Note: Due to the knife-edge roll of NDK version 11 by developers.android.com, it&#39;s recommended that ARToolKit Android developers download, install and use NDK version 11 or greater. Not doing so can result in link incompatibilities between your native libraries and their dependency on ARToolKit prebuilt native libraries. </p>
</blockquote>
<p>The next step after installing the Android SDK and NDK is to set some environment variables (recommended for both Mac OS X and Windows Desktop development environments). For Windows Desktop, the following can be defined as Windows system environment variables or exported by the Git bash shell&#39;s <code>.bash_profile</code> startup file.</p>
<ul>
<li>Set ANDROID_HOME to indicate the path to root folder of the downloaded Android SDK.</li>
<li>Set ANDROID_NDK_ROOT to indicate the path to root folder (most likely, &quot;ndk-bundle&quot;) of the downloaded NDK. The ANDROID_HOME environment variable can be used to help define NDK. <code>ANDROID_NDK_ROOT=$ANDROID_HOME/ndk-bundle</code></li>
<li>Set NDK to the same path as ANDROID_NDK_ROOT. <code>NDK=$ANDROID_NDK_ROOT</code></li>
<li>Set PATH to include a path to the <code>ndk-build[.cmd]</code> script file, that is, the path to the root folder of the NDK. The NDK environment variable can be used to help define the added path.</li>
</ul>
<p>Then, for both Mac OS X and Windows Desktop, re-source the command-line shell so that updated environment variables are seen by subsequent command-line shells. </p>
<p>Next, proceed to the &quot;android&quot; folder directly off the root folder of the ARToolKit SDK or local repository. There are two script files that are used on both the Mac OS X and Windows Desktop development environments:</p>
<ul>
<li>build.sh - builds ARToolKit Android native C/C++ binaries for several Android Application Binary Interfaces (<a href="http://developer.android.com/ndk/guides/abis.html">ABIs</a>)</li>
<li>build_native_examples.sh - builds those ARToolKit Android Studio example app projects that contain both native C/C++ and Java source code, again, for several Android ABIs</li>
</ul>
<p>Both scripts utilize the Android NDK and toolchain through the <code>ndk-build</code> script.</p>
<p>To build, from the bash command-line (for Windows Desktop, this will be the Git bash shell), execute the <code>./build.sh</code> script file, without arguments. When <code>build.sh</code> completes without errors, there will be dependencies built for several Android ABIs here: </p>
<ul>
<li>Mac OS X: <code>/[ARTK SDK or repo root]/android/libs</code></li>
<li>Windows Desktop: <code>C:\[ARTK SDK or repo root]\android\libs</code></li>
</ul>
<p>These are the ARToolKit binaries built for the various Android ABIs. The Android Studio example projects, that don&#39;t include native C/C++ source code, are populated with the content of the generated <em>libs</em> folder.</p>
<p>To build the Android Studio example app projects that do include native C/C++ source code and to build the project&#39;s C/C++ source, after executing the <code>./build</code> script file, execute <code>./build_native_examples.sh</code>, without arguments. When <code>build_native_examples.sh</code> script completes without errors, the native Android Studio example projects are populated with the content of the generated <em>libs</em> folder. Using an actual example Android Studio project, &quot;ARSimpleNativeProj,&quot; the <em>libs</em> folder is copied here:</p>
<p><code>[ARTK SDK or repo root]/AndroidStudioProjects/ARSimpleNativeProj/aRSimpleNative/src/main/</code></p>
<p>Once the native dependencies are built and copied, open an Android Studio example project and build the project&#39;s Java source files. If all builds, deploy to an Android simulated device or a <em>real</em> development device. Note: the camera doesn&#39;t work on simulated devices so it&#39;s best to test with <em>real</em> devices.</p>
<p>To use the native ARToolKit binaries in your own Android application, you will need to copy the <em>libs</em> folder generated by the &quot;build.sh&quot; script to your Android application project folder using the following project offset:</p>
<p><code>[Android Studio Project root]/[module root]/src/main</code></p>
<hr>
<h4 id="note">Note</h4>
<p>The provided ARToolKit Android Studio projects do not yet fully drive the native C/C++ build process from within the Android Studio IDE. This is partly because NDK development support is not seamlessly integrated into Android Studio as of yet. Rest assured it&#39;s the ARToolKit team&#39;s goal to achieve full native build integration with Android Studio going forward.</p>
<hr>
<h1 id="android-camera-preferences">Android Camera Preferences</h1>
<p>The provided examples incorporate a user-adjustable camera preferences screen. There are two key preferences implemented- Firstly, on devices with more than one camera, the choice of camera, and secondly, the camera resolution.</p>
<p>This preferences screen is provided as part of the ARBaseLib library in the ARToolKit for Android distribution. The class identifier is org.artoolkit.ar.base.camera.CameraPreferencesActivity. It is quite straightforward to incorporate this class into your ARToolKit application.</p>
<p>There are two approaches, depending on whether your application&#39;s AR activity inherits from org.artoolkit.ar.base.ARActivity, or whether it uses its own Activity and CameraSurface classes.</p>
<h2 id="applications-inheriting-from-aractivity">Applications Inheriting from ARActivity</h2>
<p>The example applications which inherit from ARActivity are:</p>
<ul>
<li>ARSimple</li>
<li>ARSimpleInteraction</li>
<li>ARSimpleNative</li>
<li>ARSimpleNativeCars</li>
</ul>
<p>If your application falls into this category, you need add only the essential lines of code to register the CameraPreferencesActivity in your manifest. The behavior of providing the settings menu in response to the menu button is automatically provided by the ARActivity class. The preferences chosen by the user are automatically used in the CameraPreview class.</p>
<p>Just add the following to your AndroidManifest.xml file:</p>
<p>&lt;pre&gt;
    &lt;activity android:name=&quot;org.artoolkit.ar.base.camera.CameraPreferencesActivity&quot;&gt;&lt;/activity&gt;
&lt;/pre&gt;

</p>
<h2 id="applications-using-custom-activity-subclasses">Applications using Custom Activity Subclasses</h2>
<p>The example applications which use their own Activity and CameraSurface classes are:</p>
<ul>
<li>ARNative</li>
<li>ARNativeOSG</li>
<li>nftSimple</li>
<li>nftBook</li>
<li>ARMovie</li>
</ul>
<p>If your application is based on one of these applications, a handful of changes need to be made to initialize the preferences the first time the application is run after being freshly installed, to invoke the preferences activity, and to use the actual preferences in setting up the camera.</p>
<h3 id="initialize-preference-defaults">Initialize Preference Defaults</h3>
<p>Add the following code where it will be run once per install of Application, and prior to using any of the camera preferences. If you are subclassing <code>Application.onCreate()</code> (as all the examples do), put it into <code>Application.onCreate()</code>. If not subclassing Application, put it in your <code>Activity.onCreate()</code> method.</p>
<p>&lt;pre&gt;
    import android.preference.PreferenceManager;
    PreferenceManager.setDefaultValues(this, org.artoolkit.ar.base.R.xml.preferences, false);
&lt;/pre&gt;

</p>
<h3 id="invoke-preferences-activity">Invoke Preferences Activity</h3>
<p>The suggested method of invoking the preferences activity is to make it available via your applications settings menu. This is quite straightforward. Add the following code to your Activity subclass:</p>
<p>&lt;pre&gt;
    import org.artoolkit.ar.base.camera.CameraPreferencesActivity;
    import android.view.Menu;
    import android.view.MenuInflater;
    import android.view.MenuItem;

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.options, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (item.getItemId() == R.id.settings) {
            startActivity(new Intent(this, CameraPreferencesActivity.class));
            return true;
        } else {
            return super.onOptionsItemSelected(item);
        }
    }
&lt;/pre&gt;

</p>
<p>This will use the menu resource provided by the ARBaseLib library. If you already have an options menu, you will most likely want to incorporate the existing values from ARBaseLib&#39;s res/menu/options.xml.</p>
<h3 id="using-preferences">Using Preferences</h3>
<p>Once the user has actually chosen the preferences, you need to make sure you&#39;re actually using the choices, or that you&#39;re using the default values if no choice has yet been made. This code will typically be in a class which inherits from Surface and which implements CameraPreviewCallback. Take a look at the CameraSurface class in the native examples for example usage.</p>
<p>Code to open the correct camera chosen by the user:</p>
<p>&lt;pre&gt;
    import android.os.Build;
    import android.preference.PreferenceManager;
    Camera camera = null;
    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.GINGERBREAD) camera = Camera.open(Integer.parseInt(PreferenceManager.getDefaultSharedPreferences(callingContext).getString(&quot;pref_cameraIndex&quot;, &quot;0&quot;)));
    else camera = Camera.open();
&lt;/pre&gt;

</p>
<p>Code to attempt to configure the camera resolution:</p>
<p>&lt;pre&gt;
    String camResolution = PreferenceManager.getDefaultSharedPreferences(callingContext).getString(&quot;pref_cameraResolution&quot;, getResources().getString(R.string.pref_defaultValue_cameraResolution));
    String[] dims = camResolution.split(&quot;x&quot;, 2);
    Camera.Parameters parameters = camera.getParameters();
    parameters.setPreviewSize(Integer.parseInt(dims[0]),Integer.parseInt(dims[1]));
    camera.setParameters(parameters);
&lt;/pre&gt;

</p>
<p>Don&#39;t forget that the chosen resolution may not be accepted by the camera, so don&#39;t assume that the camera preview buffers will be the preferred size. You should read back the actual size in use after setting the preferred value (e.g. when sizing buffers).</p>
<h2 id="customizing">Customizing</h2>
<p>The full source of CameraPreferencesActivity is provided and is easy to customize. The source refers to a number of resources, found at the following paths:</p>
<ul>
<li>ARBaseLib/res/drawable-hdpi/settings.png</li>
<li>ARBaseLib/res/drawable-mdpi/settings.png</li>
<li>ARBaseLib/res/drawable-xhdpi/settings.png</li>
<li>ARBaseLib/res/menu/options.xml</li>
<li>ARBaseLib/res/values/strings.xml</li>
<li>ARBaseLib/xml/preferences.xml</li>
</ul>
<p>These resources are automatically available in any project referring to ARBaseLib. If you wish to customize these, you can override in your Activity by using the same resource ID with the new value.</p>
<h2 id="a-note-on-camera-resolutions">A Note on Camera Resolutions</h2>
<p>Take care when the user chooses camera resolutions. A camera resolution with a different aspect ratio to the aspect ratio of ARToolKit&#39;s <a href="2_Configuration:config_camera_calibration">calibrated camera parameters</a> (camera_para.dat or similar) will not track correctly!</p>
<h1 id="artoolkit-s-sdk-structure-on-android">ARToolKit&#39;s SDK Structure on Android</h1>
<p>Most applications on Android are developed in Java, and Android provides a rich framework of classes to support this. It is, however, also possible to develop parts of an application in native C/C++ code using the Android NDK. This is intended for accessing existing C/C++ codebases or potentially optimizing performance critical functions.</p>
<p>The general approach is to build a native C/C++ shared library containing functions that are exposed using the JNI naming scheme. A Java application can then load the library and map the native functions to Java methods, which can then be called like any other method in Java.</p>
<p>Using this approach it is now possible to create ARToolKit applications on Android. Certain parts of these applications, must be implemented in Java, other parts can be written in C/C++. Therefore, applications will typically be a combination of C/C++, Java, and the “glue” in between.</p>
<p>This SDK includes components in both C/C++ and Java to permit the development of ARToolKit applications on Android. These components include:</p>
<ul>
<li>ARToolKit core modules. These are native static libraries which can be used to build a shared library.</li>
<li>ARToolKitWrapper: a C++ wrapper around ARToolKit, providing high level access to ARToolKit functions and marker management, with C and JNI interfaces. This is a native shared library that can be included in an Android application.</li>
<li>ARBaseLib: a Java Android library that communicates with ARToolKitWrapper. By using the classes provided ARBaseLib, an Android application gains easy access to the native functionality of ARToolKit.</li>
</ul>
<p>With these components, several development strategies are possible, ranging in complexity:</p>
<ul>
<li>Native development by creating a new shared library that links to the ARToolKit static libraries.</li>
<li>Native development by creating a new shared library that utilizes ARToolKitWrapper.</li>
<li>Java development using the provided ARBaseLib (Java) and ARToolKitWrapper (native) libraries.</li>
</ul>
<p>Note: Regardless of the approach, all applications require some Java components in order to operate as an Android application. For example, the main Activity class, and video capture classes, must be implemented in Java.</p>
<p>Examples that demonstrate basic operation of the SDK, and the various development approaches available, are included. See <a href="4_Android:android_examples">ARToolKit for Android examples</a>.</p>
<h2 id="video-capture-on-android">Video Capture on Android</h2>
<p>The ARToolKit port includes almost all of the core modules; the notable exception being the video capture module, which in other ARToolKit versions provides a standard interface for accessing video capture on different platforms and hardware.</p>
<p>Android does not currently permit camera access from native code. Instead, only Java code can open the camera and capture frames. Additionally, a live camera preview must be included in the current Activity’s view for frames to be captured. This means that ARToolKit itself cannot initiate video capture, but must instead wait on the Java application to pass video information and frames using JNI.</p>
<p>Therefore, video capture requires coordination between corresponding libraries on either side of JNI. While this forces a slightly fragmented approach, ARToolKitWrapper and ARBaseLib libraries are provided to handle the issue. Alternatively, the ARNative example included in the SDK demonstrates how to pass video independently of these libraries.</p>
<h2 id="sdk-requirements">SDK Requirements</h2>
<p>This SDK targets devices running Android 2.1 (Eclair) or later.</p>
<p>A working Android development environment with AndroidStudio is required. For native development, the Android NDK is also needed. For more details about native development see <a href="4_Android:android_native">here</a></p>
<p>The SDK is currently tested predominantly on the Mac OSX platform, however we also support development with Windows. Not actively supported but also working is the development with ARToolKit and AndroidStudio on Linux.</p>
<p>A printer will be required to print out markers.</p>
